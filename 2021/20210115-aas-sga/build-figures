#!/usr/bin/env python
"""Generate the figures for the SGA AAS poster.

/mnt/code/talks-and-plots/2021/20210115-aas-sga/build-figures --surface-brightness

"""
import os, sys, time, pdb
import argparse
import numpy as np

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
        
import legacyhalos.SGA
from legacyhalos.SGA import get_galaxy_galaxydir
from legacyhalos.SGA import DIAMCOLUMN, RACOLUMN, DECCOLUMN
#from legacyhalos.legacyhalos import legacyhalos_cosmology
#cosmo = legacyhalos_cosmology()

figdir = os.path.join('/mnt', '20210115-aas-sga')
#figdir = os.path.join(os.getenv('HOME'), 'research', 'talks', '2021', '20210115-aas-sga')
if not os.path.isdir(figdir):
    figdir = os.path.join(os.getenv('SCRATCH'), '20210115-aas-sga')
fonttype = os.path.join(os.getenv('LEGACYHALOS_CODE_DIR'), 'py', 'SGA', 'data', 'Georgia-Italic.ttf')

#os.environ['LEGACYHALOS_DIR'] = os.path.join(os.getenv('HOME'), 'research', 'projects', 'SGA')
#os.environ['LEGACYHALOS_DATA_DIR'] = figdir

def plot_style(font_scale=1.2, paper=False, talk=True):

    import seaborn as sns
    rc = {'font.family': 'serif'}#, 'text.usetex': True}
    #rc = {'font.family': 'serif', 'text.usetex': True,
    #       'text.latex.preamble': r'\boldmath'})
    palette, context = 'Set2', 'talk'
    
    if paper:
        context = 'paper'
        palette = 'deep'
        rc.update({'text.usetex': False})
    
    if talk:
        context = 'talk'
        palette = 'deep'
        #rc.update({'text.usetex': True})

    sns.set(context=context, style='ticks', font_scale=font_scale, rc=rc)
    sns.set_palette(palette, 12)

    colors = sns.color_palette()
    #sns.reset_orig()

    return sns, colors

def fig_sky(png=None):

    from astrometry.util.fits import fits_table
    from astrometry.util.util import anwcs_create_hammer_aitoff
    from astrometry.util.starutil_numpy import lbtoradec
    import matplotlib.cm as cm
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    sns, _ = plot_style(talk=True, font_scale=0.8)

    # read the sample
    S = fits_table(os.path.join(figdir, 'SGA-ellipse-v3.2.kd.fits'),
                   columns='ra dec preburned type diam in_footprint in_footprint_grz sga_id'.split())
    S.cut(S.sga_id > -1)    
    print(len(S))

    # initialize the projection
    zoom = 1
    W,H = 800,400
    #W,H = 1000,500
    #W,H = 2000,1000
    ra_center = 275.
    wcs = anwcs_create_hammer_aitoff(ra_center, 0., zoom, W, H, False)
    ok,S.x,S.y = wcs.radec2pixelxy(S.ra, S.dec)

    sgacount = np.zeros(wcs.shape, np.int16)
    np.add.at(sgacount, (S.y.astype(int), S.x.astype(int)), 1)
    x,y = W//2, H//2
    ok,rr,dd = wcs.pixelxy2radec([x, x+1, x], [y, y, y+1])
    cosdec = np.cos(np.deg2rad(dd[0]))
    dr1 = (rr[1]-rr[0])*cosdec
    dd1 = dd[1]-dd[0]
    dr2 = (rr[2]-rr[0])*cosdec
    dd2 = dd[2]-dd[0]
    pixelarea = np.hypot(dr1,dd1) * np.hypot(dr2,dd2)

    # build the figure
    fig = plt.figure(figsize=(12,8))
    plt.subplots_adjust(left=0.05, right=0.95, bottom=0.08, top=0.95)

    dec_lo = -90
    ra_labels_dec = -30

    dec_gridlines = list(range(max(dec_lo,-80), 90, 10))
    dec_gridlines_ras = np.arange(ra_center-180, ra_center+180, 1)
    ra_gridlines = range(0, 360, 30)
    ra_gridlines_decs = np.arange(dec_lo, 90, 1.)
    dec_gridlines_slope = []
    for d in dec_gridlines:
        rr = dec_gridlines_ras
        dd = np.zeros_like(rr) + d
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.1)
        dec_gridlines_slope.append((yy[-2]-yy[-1]) / (xx[-2] - xx[-1]))
    for r in ra_gridlines:
        dd = ra_gridlines_decs
        rr = np.zeros_like(dd) + r
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.1)

    ra_gridlines2 = [ra_center-180, ra_center+180]
    ra_gridlines2_decs = np.arange(dec_lo, 91, 1.)
    for r in ra_gridlines2:
        dd = ra_gridlines2_decs
        rr = np.zeros_like(dd) + r
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.5)

    ra_labels = ra_gridlines
    dec_labels = dec_gridlines
    dec_labels_ra = ra_center+180

    ok,xx,yy = wcs.radec2pixelxy(ra_labels, ra_labels_dec)
    for x,y,v in zip(xx, yy, ra_labels):
        plt.text(x, y, '%i'%(v%360), ha='center', va='top', alpha=1, fontsize=12)
    ok,xx,yy = wcs.radec2pixelxy(dec_labels_ra, dec_labels)
    for i,(x,y,v,slope) in enumerate(zip(xx, yy, dec_labels, dec_gridlines_slope)):
        dx = -20
        dy = dx * slope
        r = np.hypot(dx,dy)
        dx = dx * 15 / r
        dy = dy * 15 / r
        #print(v, 'dx,dy', dx, dy)
        plt.text(x+dx, y+dy, '%+i'%v, ha='center', va='center', alpha=1, fontsize=12)
        if v == 50:
            #angle = np.rad2deg(np.arctan2(dy, dx))
            angle = np.rad2deg(np.arctan2(yy[i+1]-yy[i-1], xx[i+1]-xx[i-1]))
            plt.text(x+dx*3, y+dy*3, 'Dec (deg)', ha='center', va='center', rotation=angle)
    # Galactic plane
    ll = np.linspace(0., 360., 720)
    bb = np.zeros_like(ll)
    rr,dd = lbtoradec(ll, bb)
    ok,xx,yy = wcs.radec2pixelxy(rr, dd)

    # Label
    ii = np.argmin(np.abs(rr - 275))
    angle = 180+np.rad2deg(np.arctan2(yy[ii+1]-yy[ii-1], xx[ii+1]-xx[ii-1]))
    plt.text(xx[ii], yy[ii], 'Galactic Plane', ha='center', va='bottom', rotation=angle)

    # Plot segments that are above min Dec and not discontinuous
    d = np.append([0], np.hypot(np.diff(xx), np.diff(yy)))
    ok = (d < 100) * (dd > dec_lo)
    istart = 0
    while istart < len(ok):
        while istart < len(ok) and ok[istart] == False:
            istart += 1
        iend = istart
        while iend < len(ok) and ok[iend] == True:
            iend += 1
        if iend != istart:
            #print('Plotting from', istart, 'to', iend, 'ok', ok[istart:iend])
            plt.plot(xx[istart:iend], yy[istart:iend], '-', color='0.6', lw=2)
        istart = iend

    ok,x,y = wcs.radec2pixelxy(ra_center, -45)
    plt.text(x, y, 'RA (deg)')

    plt.xticks([])
    plt.yticks([])
    plt.axis('equal');
    #ax = [0,W, 0.2*H, H]
    #plt.axis(ax)
    #plt.axis('equal')
    #plt.axis(ax)
    plt.gca().set_frame_on(False)

    # colorbar
    # Make zero values truly white (cmap.Blue(0) = 0.97,0.98,1.0)
    cmap = cm.Blues
    cmap.set_bad(color='white')
    density = (sgacount/pixelarea)
    density[sgacount==0] = np.nan

    im = plt.imshow(density, vmin=0, vmax=40, cmap='Blues', origin='lower', interpolation='nearest');
    ax = plt.gca()

    divider = make_axes_locatable(ax)
    cax = divider.new_vertical(size="5%", pad=0.3, pack_start=True)
    fig.add_axes(cax)

    c = fig.colorbar(im, cax=cax, orientation='horizontal')
    c.set_label(r'Surface Density (galaxies deg$^{-2}$)')

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)
        plt.close(fig)            

def fig_surface_brightness(sample, thisgalaxy, png):
    """Make one large figure with the surface brightness profile fitting results for
    a single galaxy.

    """
    import numpy.ma as ma

    from photutils import EllipticalAperture
    import matplotlib.patches as mpatches

    from astropy.visualization import ImageNormalize
    from astropy.visualization import AsinhStretch as Stretch
    from astropy.visualization import ZScaleInterval as Interval

    from legacyhalos.io import read_ellipsefit
    from legacyhalos.ellipse import ellipse_sbprofile, CogModel
    from legacyhalos.qa import _sbprofile_colors
    from legacyhalos.SGA import read_multiband

    sns, _ = plot_style(talk=True, font_scale=1.4)
    
    # https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html
    #cmap = plt.cm.plasma
    #cmap = plt.cm.cividis
    cmap = plt.cm.inferno
    #cmap = plt.cm.viridis
    stretch = Stretch(a=0.9)
    interval = Interval(contrast=0.5, nsamples=10000)

    filesuffix = 'largegalaxy'

    #print(sample)
    galaxy, galaxydir = get_galaxy_galaxydir(sample)
    this = np.where(galaxy == thisgalaxy)[0][0]

    onegal, galaxy, galaxydir = np.atleast_1d(sample)[this], np.atleast_1d(galaxy)[this], np.atleast_1d(galaxydir)[this]

    data, galaxyinfo = read_multiband(galaxy, galaxydir, filesuffix=filesuffix, verbose=True)

    igal = 1
    galaxy_id = '{}'.format(data['galaxy_id'][igal])
    #galaxy_id = '1121465'
    #galaxy_indx = 1

    # Read the data and the ellipse-fitting results.
    ellipsefit = read_ellipsefit(galaxy, galaxydir, filesuffix=filesuffix, galaxy_id=galaxy_id, verbose=True)

    band = data['bands']
    nband = len(band)

    nplot = 12
    sma_lw = 2
    sma_alpha = 0.8

    #fig, ax = plt.subplots(1, 3, figsize=(8*3, 8), sharex=True)
    fig = plt.figure(figsize=(16, 16))
    gs1 = fig.add_gridspec(3, 1, bottom=0.04, top=0.96, left=0.02, right=0.35,
                           height_ratios=[1, 1, 1], hspace=0.01)

    # [1] vertical 3-panel showing the grz data and ellipse samples
    for ii, filt in enumerate(band):
        xx = fig.add_subplot(gs1[ii])
        
        dat = data['{}_masked'.format(filt)][igal]
        img = ma.masked_array(dat.data, dat.mask)
        mask = ma.masked_array(dat.data, ~dat.mask)

        try:
            norm = ImageNormalize(img, interval=interval, stretch=stretch)
        except:
            norm = ImageNormalize(img, interval=interval)

        xx.imshow(dat, origin='lower', norm=norm, cmap=cmap, #cmap=cmap[filt],
                  interpolation='nearest')
        plt.text(0.1, 0.9, filt, transform=xx.transAxes, fontweight='bold',
                 ha='center', va='center', color='k', fontsize=26)

        smas = np.linspace(0, ellipsefit['{}_sma'.format(filt)].max(), nplot)
        for sma in smas:
            this = np.argmin(np.abs(ellipsefit['{}_sma'.format(filt)]-sma))
            xx.add_patch(mpatches.Ellipse((ellipsefit['{}_x0'.format(filt)][this], ellipsefit['{}_y0'.format(filt)][this]),
                                           2*ellipsefit['{}_sma'.format(filt)][this],
                                           2*ellipsefit['{}_sma'.format(filt)][this]*(1-ellipsefit['{}_eps'.format(filt)][this]),
                                           ellipsefit['{}_pa'.format(filt)][this]-90,
                                           color='k', lw=sma_lw, alpha=sma_alpha, fill=False))#, label='Fitted isophote')

        xx.xaxis.set_ticklabels([])
        xx.yaxis.set_ticklabels([])
        xx.xaxis.set_ticks([])
        xx.yaxis.set_ticks([])

    # [2] surface brightness and color profile
    gs2 = fig.add_gridspec(3, 1, bottom=0.08, top=0.93, left=0.42,
                           right=0.98, hspace=0.06, height_ratios=[2.9, 1.4, 2])
    
    minerr, use_ylim, plot_radius = 0.0, None, False
    
    sbprofile = ellipse_sbprofile(ellipsefit, minerr=minerr, sma_not_radius=~plot_radius,
                                  cut_on_cog=False)
    colors = _sbprofile_colors(makeiter=True)

    bands = ellipsefit['bands']
    refband = ellipsefit['refband']

    yminmax = [40, 0]
    xminmax = [0.9, 0]
    #xminmax = [1, 0]

    #fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True,
    #                               gridspec_kw = {'height_ratios':[2, 1]})
    ax1 = fig.add_subplot(gs2[0])
    ax2 = fig.add_subplot(gs2[1], sharex=ax1)
    for filt in bands:
        col = next(colors)

        mu = sbprofile['mu_{}'.format(filt)]
        muerr = sbprofile['muerr_{}'.format(filt)]
        if len(mu) == 0 or mu[0] == -1: # no good data
            continue
        radius = sbprofile['radius_{}'.format(filt)]**0.25

        ax1.fill_between(radius, mu-muerr, mu+muerr, label=r'${}$'.format(filt),
                         facecolor=col, edgecolor='k', lw=2, alpha=0.75)

        if np.nanmin(mu-muerr) < yminmax[0]:
            yminmax[0] = np.nanmin(mu-muerr)
        if np.nanmax(mu+muerr) > yminmax[1]:
            yminmax[1] = np.nanmax(mu+muerr)
        if np.nanmax(radius) > xminmax[1]:
            xminmax[1] = np.nanmax(radius)

    ax1.set_ylabel(r'$\mu$ (mag arcsec$^{-2}$)')
    #ax1.set_ylabel(r'Surface Brightness $\mu(a)$ (mag arcsec$^{-2}$)')

    ylim = [yminmax[0]-0.75, yminmax[1]+0.5]
    if ylim[0] < 17:
        ylim[0] = 17
    if ylim[1] > 33:
        ylim[1] = 33

    if use_ylim is not None:
        ax1.set_ylim(use_ylim)
    else:
        ax1.set_ylim(ylim)
    ax1.invert_yaxis()

    xlim = [xminmax[0], xminmax[1]*1.01]
    ax1.set_xlim(xlim)

    hh, ll = ax1.get_legend_handles_labels()
    if len(hh) > 0:
        leg1 = ax1.legend(loc='upper right', fontsize=18, frameon=True)
        ax1.set_title(galaxyinfo[igal]['galaxy'][0])

    # Now the color-radius plot
    if sbprofile['radius_gr'][0] != -1:
        ax2.fill_between(sbprofile['radius_gr']**0.25,
                         sbprofile['gr'] - sbprofile['gr_err'],
                         sbprofile['gr'] + sbprofile['gr_err'],
                         label=r'$g - r$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    if sbprofile['radius_rz'][0] != -1:
        ax2.fill_between(sbprofile['radius_rz']**0.25,
                         sbprofile['rz'] - sbprofile['rz_err'],
                         sbprofile['rz'] + sbprofile['rz_err'],
                         label=r'$r - z$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    hh, ll = ax2.get_legend_handles_labels()
    if len(hh) > 0:
        ax2.legend(loc='upper right', fontsize=18, frameon=True)
        #ax2.legend(bbox_to_anchor=(0.25, 0.98))

    ax2.set_ylabel('Color (mag)')
    ax2.set_ylim(-1, 3)
    ax2.set_xlim(xlim)
    #ax2.autoscale(False) # do not scale further

    for xx in (ax1, ax2):
        xx.margins(x=0)
        #xx.xaxis.set_ticklabels([])
        ylim = xx.get_ylim()
        xx.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                        [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)

    #ax2.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #    transform=ax2.transAxes, fontsize=10)
    ax1.text(0.07, 0.1, 'PSF\n(2$\sigma$)', ha='center', va='center',
             transform=ax1.transAxes, fontsize=18)

    # [3] curve of growth
    ax3 = fig.add_subplot(gs2[2], sharex=ax1)
    colors = _sbprofile_colors()

    maxsma = 0
    eps = ellipsefit['eps']
    
    yfaint, ybright = 0, 50
    for filt in bands:
        col = next(colors) # iterate here in case we're missing a bandpass

        sma = ellipsefit['{}_cog_sma'.format(filt)]
        if plot_radius:
            radius = (sma * np.sqrt(1-eps) * data['refpixscale'])**0.25 # circularized radius [arcsec]
        else:
            radius = sma**0.25 # [arcsec]

        cog = ellipsefit['{}_cog_mag'.format(filt)]
        cogerr = ellipsefit['{}_cog_magerr'.format(filt)]
        chi2 = ellipsefit['{}_cog_params_chi2'.format(filt)]
        if np.atleast_1d(cog)[0] == -1 or chi2 == 1e6: # no measurement, or failed
            continue
        magtot = ellipsefit['{}_cog_params_mtot'.format(filt)]
        m0 = ellipsefit['{}_cog_params_m0'.format(filt)]
        alpha1 = ellipsefit['{}_cog_params_alpha1'.format(filt)]
        alpha2 = ellipsefit['{}_cog_params_alpha2'.format(filt)]

        label = r'{}={:.3f} ($\chi^2_\nu={:.1f}$)'.format(filt, magtot, chi2)
            
        ax3.fill_between(radius, cog-cogerr, cog+cogerr, label=label, color=col)
        #ax3.fill_between(sma, cog-cogerr, cog+cogerr, label=label, color=col)

        cogmodel = CogModel().evaluate(sma, magtot, m0, alpha1, alpha2)
        if False:
            ax3.plot(radius, cogmodel, color='k', lw=2, ls='--', alpha=0.5)
            #ax3.plot(sma, cogmodel, color='k', lw=2, ls='--', alpha=0.5)
        if sma.max() > maxsma:
            maxsma = sma.max()

        inrange = np.where((radius >= xlim[0]) * (radius <= xlim[1]))[0]
            
        if cog[inrange].max() > yfaint:
            yfaint = cog[inrange].max()
        if cog[inrange].min() < ybright:
            ybright = cog[inrange].min()

    ax3.set_xlabel(r'(Semi-major axis $r$)$^{1/4}$ (arcsec)')
    #ax3.set_ylabel('Cumulative brightness (AB mag)')
    #ax3.set_xlabel(r'(Galactocentric radius $r$)$^{1/4}$ (arcsec)')    
    ax3.set_ylabel(r'm$(<r)$ (mag)')
    ax3.margins(x=0)

    ax3.set_xlim(xlim)
    #if maxsma > 0:
    #    ax3.set_xlim(0, maxsma*1.01)
    #else:
    #    ax3.set_xlim(0, 1) # hack!
        
    yfaint += 0.7
    ybright += -0.7
    ax3.set_ylim(yfaint, ybright)
    #ax3.xaxis.set_major_locator(ticker.MultipleLocator(0.5))

    if False:
        ax_twin = ax.twinx()
        ax_twin.set_ylim(yfaint, ybright)
        ax_twin.set_ylabel('Cumulative Flux (AB mag)')#, rotation=-90)

    if False:
        hh, ll = ax3.get_legend_handles_labels()
        if len(hh) > 0:
            leg1 = ax3.legend(loc='lower right', fontsize=14)#, ncol=3)

    ylim = ax3.get_ylim()
    ax3.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                     [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)
    #ax3.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #         transform=ax3.transAxes, fontsize=16)

        
    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--sky', action='store_true')
    parser.add_argument('--gallery', action='store_true')
    parser.add_argument('--skysub-tests', action='store_true')
    parser.add_argument('--choose-skyannulus', action='store_true')
    parser.add_argument('--ccdpos', action='store_true')
    parser.add_argument('--model-and-mask', action='store_true')
    parser.add_argument('--ellipse-multiband', action='store_true')
    parser.add_argument('--surface-brightness', action='store_true')
    parser.add_argument('--clobber', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    sample = legacyhalos.SGA.read_sample(galaxylist='PGC193199_GROUP')
    #fullsample = legacyhalos.SGA.read_sample(galaxylist='PGC193199_GROUP', preselect_sample=False)

    galaxy, galaxydir = get_galaxy_galaxydir(sample)
    for onegal in sample:
        _galaxy, _ = get_galaxy_galaxydir(onegal)
        print(_galaxy, onegal[RACOLUMN], onegal[DECCOLUMN], onegal[DIAMCOLUMN])
    
    # Fig - spatial distribution on the sky
    if args.sky:
        fig_sky(png='sga-sky.png')

    ## Fig - bivariate scatterplot of mass vs richness
    #if args.richness_vs_redshift:
    #    fig_richness_vs_redshift(sample, png='richness_vs_redshift.png')
    #
    ## Fig - gallery of clusters
    #if args.gallery:
    #    fig_gallery(sample, png='gallery.png')
    #
    ## Fig XX - CCD position
    #if args.ccdpos:
    #    fig_ccdpos(sample, thisgalaxy='0000139-017663658', png='ccdpos.png')
    #
    ## Fig - sky subtraction diagnostic plots
    #if args.skysub_tests:
    #    fig_skysub_tests(sample, png='skysub_tests.png')
    #
    ## Fig - sky subtraction annulus diagnostic plot
    #if args.choose_skyannulus:
    #    fig_choose_skyannulus(sample, png='choose_skyannulus.png')
    #
    ## Fig - model and mask multipanel plot
    #if args.model_and_mask:
    #    fig_model_and_mask(sample, thisgalaxy='0001129-034040952', png='model_and_mask.png')
    #
    ## Fig - ellipse_multiband
    #if args.ellipse_multiband:
    #    fig_ellipse_multiband(sample, thisgalaxy='0001129-034040952', png='ellipse_multiband.png')
    #
    # Fig - surface brightness
    if args.surface_brightness:
        fig_surface_brightness(sample, thisgalaxy='PGC193199_GROUP', png='PGC193199_GROUP-sbmontage.png')
        #for gal in galaxy:
        #    fig_surface_brightness(sample, thisgalaxy=gal, png='surface_brightness_{}.png'.format(gal))
        #fig_surface_brightness(sample, thisgalaxy='0000195-052316929', png='surface_brightness.png')
        #fig_surface_brightness(sample, thisgalaxy='0001129-034040952', png='surface_brightness.png')

if __name__ == '__main__':
    main()
